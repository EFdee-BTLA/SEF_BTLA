/*===========================================================================
	  C++ class	definitions	exported from UnrealScript.
	  This is automatically	generated by the tools.
	  DO NOT modify	this manually! Edit	the	corresponding .uc files	instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#ifndef IPDRV_API
#define IPDRV_API DLL_IMPORT
#endif

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern IPDRV_API	FName IPDRV_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Accepted)
AUTOGENERATE_NAME(Closed)
AUTOGENERATE_NAME(ConnectionFailed)
AUTOGENERATE_NAME(GetMasterServer)
AUTOGENERATE_NAME(LogStatLine)
AUTOGENERATE_NAME(OnAllServersReturned)
AUTOGENERATE_NAME(OnPingTimeout)
AUTOGENERATE_NAME(OnQueryFinished)
AUTOGENERATE_NAME(OnReceivedMOTDData)
AUTOGENERATE_NAME(OnReceivedPingInfo)
AUTOGENERATE_NAME(OnReceivedServer)
AUTOGENERATE_NAME(Opened)
AUTOGENERATE_NAME(ReceivedBinary)
AUTOGENERATE_NAME(ReceivedLine)
AUTOGENERATE_NAME(ReceivedText)
AUTOGENERATE_NAME(Refresh)
AUTOGENERATE_NAME(ResolveFailed)
AUTOGENERATE_NAME(Resolved)

#ifndef NAMES_ONLY


// Enum EReceiveMode is declared in "..\IpDrv\Classes\InternetLink.uc"
enum EReceiveMode
{
	 RMODE_Manual            =0,
	 RMODE_Event             =1,
	 RMODE_MAX               =2,
};
// Enum ELinkMode is declared in "..\IpDrv\Classes\InternetLink.uc"
enum ELinkMode
{
	 MODE_Text               =0,
	 MODE_Line               =1,
	 MODE_Binary             =2,
	 MODE_MAX                =3,
};

// "event"	function whose parameters correspond to	"struct AInternetLink_eventResolveFailed_Parms"	is declared	in "..\IpDrv\Classes\InternetLink.uc"
struct AInternetLink_eventResolveFailed_Parms
{
};
// "event"	function whose parameters correspond to	"struct AInternetLink_eventResolved_Parms"	is declared	in "..\IpDrv\Classes\InternetLink.uc"
struct AInternetLink_eventResolved_Parms
{
	  FIpAddr Addr;
};
// Enum ELinkState is declared in "..\IpDrv\Classes\TcpLink.uc"
enum ELinkState
{
	 STATE_Initialized       =0,
	 STATE_Ready             =1,
	 STATE_Listening         =2,
	 STATE_Connecting        =3,
	 STATE_Connected         =4,
	 STATE_ListenClosePending=5,
	 STATE_ConnectClosePending=6,
	 STATE_ListenClosing     =7,
	 STATE_ConnectClosing    =8,
	 STATE_MAX               =9,
};

// "event"	function whose parameters correspond to	"struct ATcpLink_eventReceivedBinary_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventReceivedBinary_Parms
{
	  INT Count;
	  BYTE B[255];
};
// "event"	function whose parameters correspond to	"struct ATcpLink_eventReceivedLine_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventReceivedLine_Parms
{
	  FString Line;
};
// "event"	function whose parameters correspond to	"struct ATcpLink_eventReceivedText_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventReceivedText_Parms
{
	  FString Text;
};
// "event"	function whose parameters correspond to	"struct ATcpLink_eventClosed_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventClosed_Parms
{
};
// "event"	function whose parameters correspond to	"struct ATcpLink_eventOpened_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventOpened_Parms
{
};
// "event"	function whose parameters correspond to	"struct ATcpLink_eventAccepted_Parms"	is declared	in "..\IpDrv\Classes\TcpLink.uc"
struct ATcpLink_eventAccepted_Parms
{
};

// "event"	function whose parameters correspond to	"struct AUdpLink_eventReceivedBinary_Parms"	is declared	in "..\IpDrv\Classes\UdpLink.uc"
struct AUdpLink_eventReceivedBinary_Parms
{
	  FIpAddr Addr;
	  INT Count;
	  BYTE B[255];
};
// "event"	function whose parameters correspond to	"struct AUdpLink_eventReceivedLine_Parms"	is declared	in "..\IpDrv\Classes\UdpLink.uc"
struct AUdpLink_eventReceivedLine_Parms
{
	  FIpAddr Addr;
	  FString Line;
};
// "event"	function whose parameters correspond to	"struct AUdpLink_eventReceivedText_Parms"	is declared	in "..\IpDrv\Classes\UdpLink.uc"
struct AUdpLink_eventReceivedText_Parms
{
	  FIpAddr Addr;
	  FString Text;
};

// "event"	function whose parameters correspond to	"struct AMasterServerLink_eventGetMasterServer_Parms"	is declared	in "..\IpDrv\Classes\MasterServerLink.uc"
struct AMasterServerLink_eventGetMasterServer_Parms
{
	  FString OutAddress;
	  INT OutPort;
};
// Enum EHeartbeatType is declared in "..\IpDrv\Classes\MasterServerUplink.uc"
enum EHeartbeatType
{
	 HB_QueryInterface       =0,
	 HB_GamePort             =1,
	 HB_GamespyQueryPort     =2,
	 HB_MAX                  =3,
};
// Enum EMasterToServer is declared in "..\IpDrv\Classes\MasterServerUplink.uc"
enum EMasterToServer
{
	 MTS_ClientChallenge     =0,
	 MTS_ClientAuthFailed    =1,
	 MTS_Shutdown            =2,
	 MTS_MatchID             =3,
	 MTS_MD5Update           =4,
	 MTS_MAX                 =5,
};
// Enum EServerToMaster is declared in "..\IpDrv\Classes\MasterServerUplink.uc"
enum EServerToMaster
{
	 STM_ClientResponse      =0,
	 STM_GameState           =1,
	 STM_Stats               =2,
	 STM_ClientDisconnectFailed=3,
	 STM_MD5Version          =4,
	 STM_MAX                 =5,
};
// Struct FMD5UpdateData	is declared	in "..\IpDrv\Classes\MasterServerUplink.uc"
struct IPDRV_API FMD5UpdateData
{
    FString Guid;
    FString MD5;
    INT Revision;
    friend	IPDRV_API FArchive& operator<<(FArchive& Ar,FMD5UpdateData& MyMD5UpdateData)
    {
        return	Ar	<< MyMD5UpdateData.Guid	<< MyMD5UpdateData.MD5	<< MyMD5UpdateData.Revision;
    }
};


// "event"	function whose parameters correspond to	"struct AMasterServerUplink_eventLogStatLine_Parms"	is declared	in "..\IpDrv\Classes\MasterServerUplink.uc"
struct AMasterServerUplink_eventLogStatLine_Parms
{
	  FString StatLine;
	  BITFIELD ReturnValue;
};
// "event"	function whose parameters correspond to	"struct AMasterServerUplink_eventRefresh_Parms"	is declared	in "..\IpDrv\Classes\MasterServerUplink.uc"
struct AMasterServerUplink_eventRefresh_Parms
{
};
// "event"	function whose parameters correspond to	"struct AMasterServerUplink_eventConnectionFailed_Parms"	is declared	in "..\IpDrv\Classes\MasterServerUplink.uc"
struct AMasterServerUplink_eventConnectionFailed_Parms
{
	  BITFIELD bShouldReconnect;
};
// Enum EPingCause is declared in "..\IpDrv\Classes\ServerQueryClient.uc"
enum EPingCause
{
	 PC_Unknown              =0,
	 PC_Clicked              =1,
	 PC_AutoPing             =2,
	 PC_LANBroadcast         =3,
	 PC_MAX                  =4,
};
// Enum EQueryInterfaceCommand is declared in "..\IpDrv\Classes\ServerQueryClient.uc"
enum EQueryInterfaceCommand
{
	 QI_Ping                 =0,
	 QI_Rules                =1,
	 QI_Players              =2,
	 QI_RulesAndPlayers      =3,
	 QI_SmallPing            =4,
	 QI_MAX                  =5,
};

// "event"	function whose parameters correspond to	"struct AServerQueryClient_eventOnAllServersReturned_Parms"	is declared	in "..\IpDrv\Classes\ServerQueryClient.uc"
struct AServerQueryClient_eventOnAllServersReturned_Parms
{
};
// "event"	function whose parameters correspond to	"struct AServerQueryClient_eventOnPingTimeout_Parms"	is declared	in "..\IpDrv\Classes\ServerQueryClient.uc"
struct AServerQueryClient_eventOnPingTimeout_Parms
{
	  INT ListID;
	  BYTE PingCause;
};
// "event"	function whose parameters correspond to	"struct AServerQueryClient_eventOnReceivedPingInfo_Parms"	is declared	in "..\IpDrv\Classes\ServerQueryClient.uc"
struct AServerQueryClient_eventOnReceivedPingInfo_Parms
{
	  INT ListID;
	  BYTE PingCause;
	  FServerResponseLine S;
};
// Enum EMOTDResponse is declared in "..\IpDrv\Classes\MasterServerClient.uc"
enum EMOTDResponse
{
	 MR_MOTD                 =0,
	 MR_MandatoryUpgrade     =1,
	 MR_OptionalUpgrade      =2,
	 MR_NewServer            =3,
	 MR_IniSetting           =4,
	 MR_Command              =5,
	 MR_MAX                  =6,
};
// Enum EResponseInfo is declared in "..\IpDrv\Classes\MasterServerClient.uc"
enum EResponseInfo
{
	 RI_AuthenticationFailed =0,
	 RI_ConnectionFailed     =1,
	 RI_ConnectionTimeout    =2,
	 RI_Success              =3,
	 RI_MustUpgrade          =4,
	 RI_MAX                  =5,
};
// Enum EQueryType is declared in "..\IpDrv\Classes\MasterServerClient.uc"
enum EQueryType
{
	 QT_Equals               =0,
	 QT_NotEquals            =1,
	 QT_LessThan             =2,
	 QT_LessThanEquals       =3,
	 QT_GreaterThan          =4,
	 QT_GreaterThanEquals    =5,
	 QT_MAX                  =6,
};
// Enum EClientToMaster is declared in "..\IpDrv\Classes\MasterServerClient.uc"
enum EClientToMaster
{
	 CTM_Query               =0,
	 CTM_GetMOTD             =1,
	 CTM_QueryUpgrade        =2,
	 CTM_MAX                 =3,
};
// Struct FQueryData	is declared	in "..\IpDrv\Classes\MasterServerClient.uc"
struct IPDRV_API FQueryData
{
    FString Key;
    FString Value;
    BYTE QueryType;
    friend	IPDRV_API FArchive& operator<<(FArchive& Ar,FQueryData& MyQueryData)
    {
        return	Ar	<< MyQueryData.Key	<< MyQueryData.Value	<< MyQueryData.QueryType;
    }
};


// "event"	function whose parameters correspond to	"struct AMasterServerClient_eventOnReceivedMOTDData_Parms"	is declared	in "..\IpDrv\Classes\MasterServerClient.uc"
struct AMasterServerClient_eventOnReceivedMOTDData_Parms
{
	  BYTE Command;
	  FString Value;
};
// "event"	function whose parameters correspond to	"struct AMasterServerClient_eventOnReceivedServer_Parms"	is declared	in "..\IpDrv\Classes\MasterServerClient.uc"
struct AMasterServerClient_eventOnReceivedServer_Parms
{
	  FServerResponseLine S;
};
// "event"	function whose parameters correspond to	"struct AMasterServerClient_eventOnQueryFinished_Parms"	is declared	in "..\IpDrv\Classes\MasterServerClient.uc"
struct AMasterServerClient_eventOnQueryFinished_Parms
{
	  BYTE ResponseInfo;
	  INT Info;
};
// Class	AMasterServerGameStats is declared in "..\IpDrv\Classes\MasterServerGameStats.uc"
class IPDRV_API	AMasterServerGameStats	: public AGameStats
{
public:
    class AMasterServerUplink* Uplink;
	   DECLARE_CLASS(AMasterServerGameStats,AGameStats,0|CLASS_Config,IpDrv)
	   NO_DEFAULT_CONSTRUCTOR(AMasterServerGameStats)
};

// Class	AInternetLink is declared in "..\IpDrv\Classes\InternetLink.uc"
class IPDRV_API	AInternetLink	: public AInternetInfo
{
public:
    BYTE LinkMode;
    INT Socket;
    INT Port;
    INT RemoteSocket;
    INT PrivateResolveInfo;
    INT DataPending;
    BYTE ReceiveMode;
	   DECLARE_FUNCTION(execGetLocalIP);
	   DECLARE_FUNCTION(execGameSpyGameName);
	   DECLARE_FUNCTION(execGameSpyValidate);
	   DECLARE_FUNCTION(execStringToIpAddr);
	   DECLARE_FUNCTION(execIpAddrToString);
	   DECLARE_FUNCTION(execGetLastError);
	   DECLARE_FUNCTION(execResolve);
	   DECLARE_FUNCTION(execParseURL);
	   DECLARE_FUNCTION(execIsDataPending);
	  void	eventResolveFailed()
	  {
		   ProcessEvent(FindFunctionChecked(IPDRV_ResolveFailed),NULL);
	  }
	  void	eventResolved(FIpAddr Addr)
	  {
        AInternetLink_eventResolved_Parms Parms;
		   Parms.Addr=Addr;
        ProcessEvent(FindFunctionChecked(IPDRV_Resolved),&Parms);
	  }
	   DECLARE_CLASS(AInternetLink,AInternetInfo,0|CLASS_Transient|CLASS_Config,IpDrv)
	AInternetLink();
	void Destroy();
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );	
	SOCKET& GetSocket() 
	{ 
		return *(SOCKET*)&Socket;
	}
	FResolveInfo*& GetResolveInfo()
	{
		return *(FResolveInfo**)&PrivateResolveInfo;
	}
};

// Class	ATcpLink is declared in "..\IpDrv\Classes\TcpLink.uc"
class IPDRV_API	ATcpLink	: public AInternetLink
{
public:
    BYTE LinkState;
    FIpAddr RemoteAddr;
    class UClass* AcceptClass;
    TArrayNoInit<BYTE> SendFIFO;
	   DECLARE_FUNCTION(execReadBinary);
	   DECLARE_FUNCTION(execReadText);
	   DECLARE_FUNCTION(execSendBinary);
	   DECLARE_FUNCTION(execSendText);
	   DECLARE_FUNCTION(execIsConnected);
	   DECLARE_FUNCTION(execClose);
	   DECLARE_FUNCTION(execOpen);
	   DECLARE_FUNCTION(execListen);
	   DECLARE_FUNCTION(execBindPort);
	  void	eventReceivedBinary(INT Count, BYTE* B)
	  {
        ATcpLink_eventReceivedBinary_Parms Parms;
		   Parms.Count=Count;
		   appMemcpy(&Parms.B,&B,sizeof(Parms.B));
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedBinary),&Parms);
	  }
	  void	eventReceivedLine(const FString& Line)
	  {
        ATcpLink_eventReceivedLine_Parms Parms;
		   Parms.Line=Line;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedLine),&Parms);
	  }
	  void	eventReceivedText(const FString& Text)
	  {
        ATcpLink_eventReceivedText_Parms Parms;
		   Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedText),&Parms);
	  }
	  void	eventClosed()
	  {
		   ProcessEvent(FindFunctionChecked(IPDRV_Closed),NULL);
	  }
	  void	eventOpened()
	  {
		   ProcessEvent(FindFunctionChecked(IPDRV_Opened),NULL);
	  }
	  void	eventAccepted()
	  {
		   ProcessEvent(FindFunctionChecked(IPDRV_Accepted),NULL);
	  }
	   DECLARE_CLASS(ATcpLink,AInternetLink,0|CLASS_Transient|CLASS_Config,IpDrv)
	ATcpLink();
	void PostScriptDestroyed();
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );	

	void CheckConnectionAttempt();
	void CheckConnectionQueue();
	void PollConnections();
	UBOOL FlushSendBuffer();
	void ShutdownConnection();
	virtual UBOOL ShouldTickInEntry() { return true; }
};

// Class	AUdpLink is declared in "..\IpDrv\Classes\UdpLink.uc"
class IPDRV_API	AUdpLink	: public AInternetLink
{
public:
    INT BroadcastAddr;
	   DECLARE_FUNCTION(execReadBinary);
	   DECLARE_FUNCTION(execReadText);
	   DECLARE_FUNCTION(execSendBinary);
	   DECLARE_FUNCTION(execSendText);
	   DECLARE_FUNCTION(execBindPort);
	  void	eventReceivedBinary(FIpAddr Addr, INT Count, BYTE* B)
	  {
        AUdpLink_eventReceivedBinary_Parms Parms;
		   Parms.Addr=Addr;
		   Parms.Count=Count;
		   appMemcpy(&Parms.B,&B,sizeof(Parms.B));
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedBinary),&Parms);
	  }
	  void	eventReceivedLine(FIpAddr Addr, const FString& Line)
	  {
        AUdpLink_eventReceivedLine_Parms Parms;
		   Parms.Addr=Addr;
		   Parms.Line=Line;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedLine),&Parms);
	  }
	  void	eventReceivedText(FIpAddr Addr, const FString& Text)
	  {
        AUdpLink_eventReceivedText_Parms Parms;
		   Parms.Addr=Addr;
		   Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedText),&Parms);
	  }
	   DECLARE_CLASS(AUdpLink,AInternetLink,0|CLASS_Transient|CLASS_Config,IpDrv)
	AUdpLink();
	void PostScriptDestroyed();
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );	
	FSocketData GetSocketData();
};

// Class	AMasterServerLink is declared in "..\IpDrv\Classes\MasterServerLink.uc"
class IPDRV_API	AMasterServerLink	: public AInfo
{
public:
    INT LinkPtr;
    INT LANPort;
    INT LANServerPort;
    INT CurrentMasterServer;
    INT MasterServerPort[5];
    FStringNoInit MasterServerAddress[5];
	   DECLARE_FUNCTION(execPoll);
	  void	eventGetMasterServer(FString& OutAddress, INT& OutPort)
	  {
        AMasterServerLink_eventGetMasterServer_Parms Parms;
		   Parms.OutAddress=OutAddress;
		   Parms.OutPort=OutPort;
        ProcessEvent(FindFunctionChecked(IPDRV_GetMasterServer),&Parms);
		   OutAddress=Parms.OutAddress;
		   OutPort=Parms.OutPort;
	  }
	   DECLARE_CLASS(AMasterServerLink,AInfo,0|CLASS_Transient|CLASS_Config,IpDrv)
	virtual UBOOL Poll( INT WaitTime ) { return 0; }
};

// Class	AMasterServerUplink is declared in "..\IpDrv\Classes\MasterServerUplink.uc"
class IPDRV_API	AMasterServerUplink	: public AMasterServerLink
{
public:
    FServerResponseLine ServerState;
    class AMasterServerGameStats* GameStats;
    INT MatchID;
    FLOAT ReconnectTime;
    BITFIELD bReconnectPending:1;
    BITFIELD ServerBehindNAT:1;
    BITFIELD DoLANBroadcast:1;
	   DECLARE_FUNCTION(execLogStatLine);
	   DECLARE_FUNCTION(execReconnect);
	  BITFIELD	eventLogStatLine(const FString& StatLine)
	  {
        AMasterServerUplink_eventLogStatLine_Parms Parms;
		   Parms.ReturnValue=0;
		   Parms.StatLine=StatLine;
        ProcessEvent(FindFunctionChecked(IPDRV_LogStatLine),&Parms);
		   return Parms.ReturnValue;
	  }
	  void	eventRefresh()
	  {
		   ProcessEvent(FindFunctionChecked(IPDRV_Refresh),NULL);
	  }
	  void	eventConnectionFailed(BITFIELD bShouldReconnect)
	  {
        AMasterServerUplink_eventConnectionFailed_Parms Parms;
		   Parms.bShouldReconnect=bShouldReconnect;
        ProcessEvent(FindFunctionChecked(IPDRV_ConnectionFailed),&Parms);
	  }
	   DECLARE_CLASS(AMasterServerUplink,AMasterServerLink,0|CLASS_Transient|CLASS_Config,IpDrv)
	// AActor interface
	void Destroy();
	void PostScriptDestroyed();
	// AServerQueryLink interface
	UBOOL Poll( INT WaitTime );
};

// Class	AServerQueryClient is declared in "..\IpDrv\Classes\ServerQueryClient.uc"
class IPDRV_API	AServerQueryClient	: public AMasterServerLink
{
public:
    BITFIELD bLANQuery:1;
    FScriptDelegate __OnReceivedPingInfo__Delegate;
    FScriptDelegate __OnPingTimeout__Delegate;
    FScriptDelegate __OnAllServersReturned__Delegate;
	   DECLARE_FUNCTION(execCancelPings);
	   DECLARE_FUNCTION(execPingServer);
	  void	delegateOnAllServersReturned()
	  {
		   ProcessDelegate(IPDRV_OnAllServersReturned,&__OnAllServersReturned__Delegate,NULL);
	  }
	  void	delegateOnPingTimeout(INT ListID, BYTE PingCause)
	  {
        AServerQueryClient_eventOnPingTimeout_Parms Parms;
		   Parms.ListID=ListID;
		   Parms.PingCause=PingCause;
		   ProcessDelegate(IPDRV_OnPingTimeout,&__OnPingTimeout__Delegate,&Parms);
	  }
	  void	delegateOnReceivedPingInfo(INT ListID, BYTE PingCause, FServerResponseLine S)
	  {
        AServerQueryClient_eventOnReceivedPingInfo_Parms Parms;
		   Parms.ListID=ListID;
		   Parms.PingCause=PingCause;
		   Parms.S=S;
		   ProcessDelegate(IPDRV_OnReceivedPingInfo,&__OnReceivedPingInfo__Delegate,&Parms);
	  }
	   DECLARE_CLASS(AServerQueryClient,AMasterServerLink,0|CLASS_Transient|CLASS_Config,IpDrv)
	// AActor interface
	void Destroy();
	void PostScriptDestroyed();
	// MasterServerLink interface
	UBOOL Poll( INT WaitTime );
	// ServerQueryClient interface
	void Init();
};

// Class	AMasterServerClient is declared in "..\IpDrv\Classes\MasterServerClient.uc"
class IPDRV_API	AMasterServerClient	: public AServerQueryClient
{
public:
    INT MSLinkPtr;
    TArrayNoInit<FQueryData> Query;
    INT ResultCount;
    FScriptDelegate __OnQueryFinished__Delegate;
    FScriptDelegate __OnReceivedServer__Delegate;
    FScriptDelegate __OnReceivedMOTDData__Delegate;
	   DECLARE_FUNCTION(execLaunchAutoUpdate);
	   DECLARE_FUNCTION(execStop);
	   DECLARE_FUNCTION(execStartQuery);
	  void	delegateOnReceivedMOTDData(BYTE Command, const FString& Value)
	  {
        AMasterServerClient_eventOnReceivedMOTDData_Parms Parms;
		   Parms.Command=Command;
		   Parms.Value=Value;
		   ProcessDelegate(IPDRV_OnReceivedMOTDData,&__OnReceivedMOTDData__Delegate,&Parms);
	  }
	  void	delegateOnReceivedServer(FServerResponseLine S)
	  {
        AMasterServerClient_eventOnReceivedServer_Parms Parms;
		   Parms.S=S;
		   ProcessDelegate(IPDRV_OnReceivedServer,&__OnReceivedServer__Delegate,&Parms);
	  }
	  void	delegateOnQueryFinished(BYTE ResponseInfo, INT Info)
	  {
        AMasterServerClient_eventOnQueryFinished_Parms Parms;
		   Parms.ResponseInfo=ResponseInfo;
		   Parms.Info=Info;
		   ProcessDelegate(IPDRV_OnQueryFinished,&__OnQueryFinished__Delegate,&Parms);
	  }
	   DECLARE_CLASS(AMasterServerClient,AServerQueryClient,0|CLASS_Transient|CLASS_Config,IpDrv)
	// AActor interface
	void Destroy();
	void PostScriptDestroyed();
	// MasterServerLink interface
	UBOOL Poll( INT WaitTime );
	// ServerQueryClient interface
	void Init();
};

#endif

AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLocalIP);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGameSpyGameName);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGameSpyValidate);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execStringToIpAddr);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIpAddrToString);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLastError);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execResolve);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execParseURL);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIsDataPending);
AUTOGENERATE_FUNCTION(AMasterServerClient,-1,execLaunchAutoUpdate);
AUTOGENERATE_FUNCTION(AMasterServerClient,-1,execStop);
AUTOGENERATE_FUNCTION(AMasterServerClient,-1,execStartQuery);
AUTOGENERATE_FUNCTION(AMasterServerLink,-1,execPoll);
AUTOGENERATE_FUNCTION(AMasterServerUplink,-1,execLogStatLine);
AUTOGENERATE_FUNCTION(AMasterServerUplink,-1,execReconnect);
AUTOGENERATE_FUNCTION(AServerQueryClient,-1,execCancelPings);
AUTOGENERATE_FUNCTION(AServerQueryClient,-1,execPingServer);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execIsConnected);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execClose);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execOpen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execListen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execBindPort);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execReadBinary);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execReadText);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execSendBinary);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execSendText);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execBindPort);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#if SUPPORTS_PRAGMA_PACK
#pragma pack	(pop)
#endif

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(AInternetLink)
VERIFY_CLASS_SIZE_NODIE(AMasterServerClient)
VERIFY_CLASS_SIZE_NODIE(AMasterServerGameStats)
VERIFY_CLASS_SIZE_NODIE(AMasterServerLink)
VERIFY_CLASS_SIZE_NODIE(AMasterServerUplink)
VERIFY_CLASS_SIZE_NODIE(AServerQueryClient)
VERIFY_CLASS_SIZE_NODIE(ATcpLink)
VERIFY_CLASS_SIZE_NODIE(AUdpLink)
#endif // VERIFY_CLASS_SIZES
